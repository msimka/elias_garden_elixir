---

# ELIAS ULM Learning Content
ulm_metadata:
  source_file: "/Users/mikesimka/elias_garden_elixir/apps/mfc/learning_sandbox/ulm_inbox/LORA_inventor.rtf"
  content_type: "paper"
  language: "en"
  converted_date: "2025-08-31T02:55:00.775312Z"
  converter_version: "mfc-1.0"
  ready_for_learning: true
---
# Converted Document **Source Format:** unknown **Extraction Method:** native_elixir_rtf_parser **Extracted At:** 2025-08-31 02:55:00.773314Z --- Low-rank adaptation, or LoRA, a0 allows you to efficiently customize a0 a0 pre-trained neural networks such as a0 diffusion models or language models. It speeds up training. And drastically reduces a0 the size of model checkpoints by training very a0 a0 few parameters compared to the base model while a0 preserving the performance of full fine-tuning, a0 a0. And it has become one of the go-to a0 methods for customizing AI models. My name is Edward Hu,. And I led the invention a0 of LoRA when I was a researcher at Microsoft. In this video, I'll share the research a0 story behind LoRA, how I understand it, a0 a0. And its technical benefits. How we came up with LoRA It was early 2021. And GPT-3 just came out the a0 year before -- feels like such a long time ago. Microsoft at the time just partnered a0 up with OpenAI. My team at Microsoft a0 a0 was tasked with answering "can this a0 GPT-3 stuff actually make money?" A somewhat surprising finding was a0 that few-shot prompting was not a0 a0 enough to get even the largest models a0 to perform. Well enough for production, a0 a0 especially for tasks like natural language to code a0 because it rarely appears in the training data. Fine-tuning through gradient a0 updates was a necessity. However, full fine tuning is prohibitively a0 expensive: a single model checkpoint for the a0 a0 175 billion parameter variant is 1 Terabyte large, a0 which is hard to store. And takes minutes to load a0 a0 when deployed,. And that's not going to work when a0 we need to switch among tasks. And users rapidly. We tried many off-the-shelf parameter-efficient a0 a0 fine-tuning methods. But all of them a0 had to compromise for our case. It was with product impact in a0 mind that we invented LoRA. What is LoRA?.\n\nSo what is LoRA? I like to see it as a generalization of a0 full fine-tuning by asking two questions. Question one: do we need to a0 find- tune all the parameters? Question two: for the weight a0 matrices we fine-tune, a0 a0 how expressive should the updates a0 be in terms of matrix rank? We can turn these two questions a0 into the two axes of a 2D plane. A0 Full fine-tuning is all the way a0 in the upper-right corner. And a0 a0 the axes, including the origin, a0 correspond to the original model. Any point in this box is a a0 valid LoRA configuration. Let's quickly talk about how a0 we control the expressivity a0 a0 of a matrix update by controlling its rank. A d by d matrix can represent any linear a0 transformation in a d-dimensional vector a0 a0 space. However, if we start with a vector in R^d, a0 first transform it to R^r where r is less than d, a0 a0. And finally transform it back a0 to R^d, we restrict the kind of a0 a0 linear transformations we can represent. How does stopping by R^r achieve that? Imagine the extreme case where r or a0 rank equals one -- whatever the input a0 a0 does boils down to just one number, a0 which can only scale the output. By picking a small r, the kind a0 of linear transformation we can a0 a0 represent is greatly limited, even a0 though the output is still in R^d.\n\nNow we only have to store 2 * d a0 * r parameters instead of d^2. This is how LoRA stores matrix updates.\n\nNow back to the 2D plane we talked about. A surprising result of the LoRA a0 paper is that a point near the a0 a0 origin can perform just as. Well as full a0 fine-tuning all the way in the corner. Once we see LoRA as a generalization of full a0 fine-tuning, we can easily answer some commonly a0 a0 asked questions for using LoRA such as how to a0 choose the rank R or when to use full fine-tuning. How to choose the rank r? Since full fine-tuning is a special case of a0 LoRA,. And we know that full fine-tuning works, a0 a0 we can start with a point near the origin a0. And work our way back to the corner. At some point, this has to a0 work. And more likely than not, a0 a0 what ended up working will be near the origin. Otherwise, just give up. And do full a0 fine-tuning. How may that happen? Let's consider a thought experiment: if a0 we take a language model pre-trained on a0 a0 English. And English only,. But we want to a0 adapt it for some tasks, say, in Martian, a0 a0. And let's say that English. And a0 Martian have little in common. Since we're basically training the model all a0 over again, parameter efficient fine-tuning a0 a0 methods shouldn't work too well,.\n\nSo we a0 might as. Well do full fine-training instead. Does LoRA work for my model architecture? Another question is "can I use LoRA a0 for a certain model architecture, a0 a0 say, a WaveNet or a Support Vector Machine?". And by the way, nobody really asks about a0 the latter,. But as long as the model uses a0 a0 matrix multiplication, we can ask: do a0 we need to fine-tune all the parameters a0 a0. And how expressive should updates be? As a0 long as we can ask these two questions, a0 a0 we can use LoRA, which makes a0 it very generally applicable. Indeed, while we invented LoRA a0 for large language models, a0 a0 people later found it to be very a0 effective for diffusion models as well.\n\nI want to point out that one advantage of a0 LoRA is that it's clear what to do next a0 a0 if it underperforms: we adapt more a0 parameters. And increase the rank. For approaches like prefix a0 tuning, BitFit, or adapters, a0 a0 it's not clear what we can do a0 next because there isn't a knob a0 a0 to turn that allow these methods to a0 recover full fine-tuning unlike LoRA. Benefits of using LoRA.\n\nNow let's dive into the specifics a0 of the benefits of LoRA. The most visible one is a a0 reduction of checkpoint sizes. On GPT-3, we reduce the checkpoint a0 size from 1TB down to 25MB. A0 This is a direct result of a0 training much fewer parameters: a0 a0 4.7 million in this case compared to 175 billion. Another important benefit is that LoRA a0 doesn't introduce any inference latency. You might say "hold on, do we have these a0 additional low rank matricies on the side?" Well, that's true during training. What happens during inference is that since LoRA a0 updates are additive to the original parameters, a0 a0 we can expand the low-rank matricies a0 by multiplying out the low-rank bottle a0 a0. And add the updates to the original parameters.\n\nNow, we can perform inference literally a0 the same way as with a base model, a0 a0. And there is no additional latency by definition. When we need to switch tasks we simply repeat a0 the process,. But this time subtract the updates. By being careful about numerical precisions a0 we can recover the original parameters, a0 a0. And we repeat to load another LoRA module. This process can be done in a0 parallel for all parameters a0 a0. And is faster than a single forward pass. This is how we can switch models quickly without a0 introducing any additional inference latency. Engineering ideas enabled by LoRA Finally, I want to mention a few a0 engineering ideas enabled by LoRA. The first one is to cache many LoRA a0 modules in RAM during deployment, a0 a0.\n\nSo model switching simply involves a0 data transfer between RAM. And VRAM. Since RAM is usually much larger than VRAM, a0 a0 we can cache thousands of LoRA modules. And a0 never worry about reading from the disk again. Another idea is to train multiple LoRA a0 modules in parallel, each on its own task. This is achieved by sharing the same a0 base model. And routing different inputs a0 a0 in a single batch through different LoRA modules. This way, we can batch different LoRA a0 jobs together. And fully utilize the GPUs. There are several community implementations of a0 this which I have linked in the video description. The final idea uses the fact a0 that LoRA modules are additive. Imagine a pipeline where a pre-trained a0 model is gradually specialized. Maybe it's first fine-tuned for a particular a0 language,. And then a particular domain, a0 a0. And finally a particular task a0 or even a specific spefic user. The adapted models form a tree, a0 a0 each nonroot node can be a LoRA module a0 on top of the sum of its ancestors. The model rank can be larger a0 near the root. And smaller near a0 a0 the leaves to accommodate different dataset sizes. Model switching here becomes tree traversal, a0 a0. And we never have to load the a0 base model more than once.\n\nLet me know in the comments if a0 you have any cool ideas on how a0 a0 LoRA can be used or extended or a0 if you just have any questions. I'll see you in the next video --- *Converted using Multi-Format Converter (Tank Building Stage 2)*